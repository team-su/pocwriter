{
  "[poc writer][misc] python pty console": {
    "scope": "python",
    "prefix": "import pty",
    "body": [
      "import pty",
      "pty.spawn(\"/bin/bash\")"
    ],
    "description": "spawn a pty python console"
  },
  "[poc writer][misc] python main function template": {
    "scope": "python",
    "prefix": "if __name__ == '__main__':",
    "body": [
      "",
      "if __name__ == '__main__':",
      "    $0"
    ],
    "description": "python main function template"
  },
  "[poc writer][misc] uv init template": {
    "scope": "python",
    "prefix": "# /// script",
    "body": [
      "# /// script",
      "# requires-python = \">=3.10\"",
      "# dependencies = [",
      "#     \"${1:requests}\",",
      "# ]",
      "# ///",
      "",
      "",
      "def main() -> None:",
      "    print(\"Hello from 1.py!\")",
      "",
      "",
      "if __name__ == \"__main__\":",
      "    main()",
      ""
    ],
    "description": "uv init template"
  },
  "[poc writer][python] charsets": {
    "scope": "python",
    "prefix": "import string",
    "body": [
      "import string",
      "",
      "# Common character sets",
      "LOWERCASE = string.ascii_lowercase  # abcdefghijklmnopqrstuvwxyz",
      "UPPERCASE = string.ascii_uppercase  # ABCDEFGHIJKLMNOPQRSTUVWXYZ",
      "DIGITS = string.digits              # 0123456789",
      "HEXDIGITS = string.hexdigits        # 0123456789abcdef",
      "PUNCTUATION = string.punctuation    # !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~",
      "WHITESPACE = string.whitespace      # \\t\\n\\r\\x0b\\x0c ",
      "",
      "# Combined character sets",
      "ALPHABETIC = LOWERCASE + UPPERCASE",
      "ALPHANUMERIC = ALPHABETIC + DIGITS",
      "PRINTABLE = string.printable        # All printable characters",
      "",
      "charsets = ${1:LOWERCASE + UPPERCASE + DIGITS + HEXDIGITS + PUNCTUATION + WHITESPACE}",
      ""
    ],
    "description": "Common character sets in Python using the string module"
  },
  "[poc writer][python] print debug to stderr": {
    "prefix": "def debug_print(**args, **kwargs):",
    "body": [
      "def debug_print(**args, **kwargs):",
      "    import sys",
      "    kwargs.setdefault('file', sys.stderr)",
      "    print(*args, **kwargs)",
      "    "
    ],
    "description": "Prints a debug message with the variable name and value"
  },
  "[poc writer][python] brute force string one by one": {
    "prefix": "def",
    "body": [
      "# usage: ",
      "# def checker(attempt: str) -> bool: ...",
      "# charset: characters to try",
      "# guessed: current guessed string",
      "# max_length: maximum length of the string to guess",
      "# returns: the guessed string",
      "#   password = dump_string(checker, charset=string.ascii_hexdigits, max_length=20)",
      "from typing import Callable",
      "import string",
      "def dump_string(checker: Callable[..., bool], charset = string.hexdigits, guessed = \"\", max_length: int = 32) -> str:",
      "    if len(guessed) >= max_length:",
      "        return guessed ",
      "    Found = False",
      "    for c in charset:",
      "        if Found:",
      "            break",
      "        attempt = guessed + c # + \"*\" # Wildcard for SQL LIKE queries or regex ",
      "        if checker(attempt): # Check if the current attempt is valid",
      "            print(f\"Found: {c}, current string grows to `{attempt}`\")",
      "            # If valid, continue to build the string",
      "            guessed = dump_string(checker, charset, attempt, max_length)",
      "            Found = True",
      "        else:",
      "            print(f\"Rejected: {c}, current string remains `{guessed}`\")",
      "            pass",
      "    if not Found:",
      "        print(f\"All characters rejected for prefix `{guessed}`\")",
      "        return guessed",
      "    return guessed",
      "",
      ""
    ],
    "description": "Brute force a string one character at a time using a checker function"
  },
  "[poc writer][python] brute force string with ascii code binary search": {
    "prefix": "def binary_search",
    "scope": "python",
    "body": [
      "from typing import Callable",
      "base_start = 33",
      "base_end = 127",
      "# Binary search for the next character",
      "# current: the current guessed string",
      "# callable: a function that takes the current guessed string and a character code",
      "#   and returns == 0 if completely matched!  ",
      "#   returns < 0 if the guessed string is bigger than the target",
      "#   returns > 0 if the guessed string is smaller than the target (or equal)",
      "#   raise IndexError if the guessed string is complete / no more characters to guess",
      "#   quick: def test(guessed: str, mid: int) -> bool:",
      "#      return ord(target_str[len(guessed)]) - mid",
      "#      return 1 if ord(target[len(guessed)]) - mid >= 0 else -1",
      "#      return -1 if ord(target[len(guessed)]) < mid else 1",
      "# low: the lowest character code to try",
      "# high: the highest character code to try",
      "# max_depth: the maximum depth of the string we want to guess",
      "# returns the guessed string",
      "def ${1:binary_search}(current: str, callable: Callable[[str, int], int],low: int = base_start, high: int = base_end, max_depth: int = 32) -> str:",
      "    if max_depth == 0:",
      "        print(\"Max depth reached\")",
      "        return current",
      "    if low > high:",
      "        return current",
      "    mid = (low + high) // 2",
      "    res = callable(current, mid)",
      "    print(f\"status: {'=' if res ==0 else '<' if res <0 else '>' }, current: {current} + {mid}({chr(mid)}) range: [{low},{high}]\")",
      "    if res == 0 or low + 1 == high: # equal",
      "        print(f\"Found char: {current + chr(mid)}\")",
      "        try:",
      "          return ${1:binary_search}(current + chr(mid), callable, base_start, base_end, max_depth - 1)",
      "        except IndexError:",
      "          # no more chars need to find",
      "          return current + chr(mid)",
      "    elif res < 0: # less than",
      "        return ${1:binary_search}(current, callable, low, mid, max_depth)",
      "    else:",
      "        return ${1:binary_search}(current, callable, mid, high, max_depth)",
      "",
      "target = \"hello,world!\"",
      "count = 0",
      "def test(guessed: str, mid: int) -> int:",
      "    global count ",
      "    count+=1",
      "    print(f\"[call count {count}]\")",
      "    #return 1 if ord(target[len(guessed)]) - mid >= 0 else -1",
      "    #return ord(target[len(guessed)]) - mid",
      "    return -1 if ord(target[len(guessed)]) < mid else 1"
    ],
    "description": "Brute force a string using binary search on ASCII codes"
  }
}