{
  "[pocwriter] python threading template": {
    "scope": "python",
    "prefix": "import threading",
    "body": [
      "import threading",
      "",
      "# Define the function to be executed in each thread",
      "def $1($2):",
      "    $3",
      "    pass",
      "",
      "def threading_run():",
      "    threads = []",
      "    for i in range($4):",
      "        t = threading.Thread(target=$1, name='$1-{}'.format(i), args=($5,))",
      "        threads.append(t)",
      "        t.start()",
      "    ",
      "    # Wait for all threads to complete",
      "    for t in threads:",
      "        t.join()"
    ],
    "description": "Python threading template with thread creation and joining"
  },
  "[pocwriter] python threading pool template": {
    "scope": "python",
    "prefix": "from concurrent.futures import ThreadPoolExecutor",
    "body": [
      "from concurrent.futures import ThreadPoolExecutor, as_completed",
      "",
      "# Define the function to be executed in each thread",
      "def $1($2):",
      "    $3",
      "    pass",
      "",
      "def threading_pool_run():",
      "    results = []",
      "    with ThreadPoolExecutor(max_workers=$4) as executor:",
      "        for i in range($5):",
      "            future = executor.submit($1, $6)",
      "            future_to_task[future] = i",
      "",
      "        for future in as_completed(future_to_task):",
      "            task_id = future_to_task[future]",
      "            try:",
      "                result = future.result()",
      "                results.append(result)",
      "                $0",
      "            except Exception as e:",
      "                print(f'Task {task_id} generated an exception: {e}')",
      "    return results"
    ],
    "description": "Python threading pool template using ThreadPoolExecutor"
  },
  "[pocwriter] python threading background service": {
    "scope": "python",
    "prefix": "import threading",
    "body": [
      "import threading",
      "import queue",
      "",
      "# Define a queue to pass data from the server thread to the main thread",
      "data_queue = queue.Queue()",
      "",
      "def ${1:background_service}(args):",
      "    # host, port = args",
      "    # server_address = (host, port)",
      "    # httpd = ThreadedHTTPServer(server_address, MyHandler)",
      "    # print(f\"Server started on {host}:{port}\")",
      "    # httpd.serve_forever()",
      "    # usage: data_queue.put(\"sample data from server\")",
      "    pass",
      "",
      "def start_${1:background_service}():",
      "    # Start the HTTP server in a separate thread",
      "    server_thread = threading.Thread(target=${1:background_service}, args=($2,))",
      "    server_thread.daemon = False  # Allow the main program to exit even if server thread is running",
      "    server_thread.start()",
      "    try:",
      "        while True:",
      "            # Check for data in the queue from the server thread",
      "            if not data_queue.empty():",
      "                received_data = data_queue.get()",
      "                print(f\"received data: {received_data}\")",
      "                ",
      "                break # exit the loop after processing the data",
      "                ",
      "            # You can perform other tasks in the main thread here",
      "            threading.Event().wait(0.5) # Simulate some work, or wait for 0.5 seconds",
      "    except KeyboardInterrupt:",
      "        print(\"Received KeyboardInterrupt, shutting down...\")"
    ],
    "description": "Python threading background service template with inter-thread communication"
  }
}